import numpy as np
from numpy.linalg import inv
from scipy.ndimage.filters import *

def stereo_disparity_best(Il, Ir, bbox, maxd):
    """
    Best stereo correspondence algorithm.

    This function computes a stereo disparity image from left stereo 
    image Il and right stereo image Ir. Only disparity values within
    the bounding box region are evaluated.

    Parameters:
    -----------
    Il    - Left stereo image, m x n pixel np.array, greyscale.
    Ir    - Right stereo image, m x n pixel np.array, greyscale.
    bbox  - 2x2 np.array, bounding box, relative to left image, from top left
            corner to bottom right corner (inclusive).
    maxd  - Integer, maximum disparity value; disparities must be within zero
            to maxd inclusive (i.e., don't search beyond rng)

    Returns:
    --------
    Id  - Disparity image (map) as np.array, same size as Il, greyscale.
    """
    # From the disparity map generated by part 1, you can see that the image 
    # is still pretty noisy and increasing the window size to 15  
    # to smooth out the image sacrified the accuracy of the map. Therefore, 
    # a sharpening filter is added to the left and right image to intensify the
    # edges so it would be easier to do stereo mapping with SAD. 
    # Once the disparity map is obtained, median and percentile filter is applied to the 
    # generated disparity map to smooth out the salt and pepper noise. 

    #--- FILL ME IN ---

    # Your code goes here.
    window = 5
    half_window = int(window/2)
    sad = np.zeros((1, 2*maxd))
    offset = np.zeros((1, 2*maxd))
    Id = np.zeros(np.shape(Il)) 
    # sharpening the input left and right image
    sharp_kernel = np.array([[0, -1, 0], 
                             [-1, 5, -1], 
                             [0, -1, 0]])
    Ir = convolve(Ir, sharp_kernel, mode = 'constant')
    Il = convolve(Il, sharp_kernel, mode = 'constant')

    # pad the left and right images 
    Il_padded = np.pad(Il, half_window, mode = 'edge')
    Ir_padded = np.pad(Ir, half_window, mode = 'edge')
    _, padded_width = np.shape(Il_padded)

    # loop through each pixel within the bounding box
    for i in range (bbox[1, 0], bbox[1, 1] + 1):
        # print(i)
        for j in range (bbox[0, 0], bbox[0, 1] + 1):
            left = Il_padded[i : i + window, j : j + window]
            num = 0
            for k in range (-maxd, maxd):
                # bounds check
                if (j + k + half_window) < (padded_width - half_window) and (j + k + half_window) > (half_window - 1) :
                    right = Ir_padded[i : i + window, (j + k) : (j + k) + window]
                    sum_diff = np.sum(np.abs(left - right))
                    sad[0, num] = sum_diff #value 
                    offset[0, num] = abs(k) #offset
                # if out of bounds, assign negative values to distinguish it from 
                # the within bounds pixels
                else: 
                    sad[0, num] = -10
                    offset[0, num] = abs(k)
                num += 1
            s = sad[0]
            s[s < 0] = np.amax(s) #change 0 to max number 
            best_match = np.argmin(s) #find the min 
            Id[i,j] = offset[0, best_match] # assign disparity to Id
    #------------------
    # apply median median and then percentile fiter to the bounding box area 
    Id[bbox[1,0]: bbox[1,1]+1, bbox[0,0]:bbox[0,1]+1] = median_filter(Id[bbox[1,0]: bbox[1,1]+1, bbox[0,0]:bbox[0,1]+1], size=13) 
    Id[bbox[1,0]: bbox[1,1]+1, bbox[0,0]:bbox[0,1]+1] = percentile_filter(Id[bbox[1,0]: bbox[1,1]+1, bbox[0,0]:bbox[0,1]+1],40, size=15) 
    return Id
